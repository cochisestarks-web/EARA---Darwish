<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EARA v1.0 - Workforce Analytics Simulation</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #1a1a1a;
            color: #e0e0e0;
            padding: 20px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 2.5rem;
            color: #00d9ff;
            margin-bottom: 10px;
        }

        .subtitle {
            color: #888;
            font-size: 1.1rem;
        }

        .badge {
            display: inline-block;
            background: #2a2a2a;
            color: #00ff88;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 0.9rem;
            margin: 5px;
        }

        .badge.warning {
            color: #ff9500;
        }

        .badge.critical {
            color: #ff3b30;
        }

        /* ========================================
           PHASE 2: Financial Dashboard Styles
           ======================================== */

        .financial-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .financial-card {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #00d9ff;
        }

        .financial-card.loss {
            border-left-color: #ff3b30;
        }

        .financial-card.zombie {
            border-left-color: #ff9500;
        }

        .financial-value {
            font-size: 2rem;
            font-weight: bold;
            margin-bottom: 5px;
            color: #fff;
        }

        .financial-label {
            color: #888;
            font-size: 0.9rem;
        }

        .financial-details {
            margin-top: 10px;
            font-size: 0.8rem;
            color: #aaa;
        }

        /* ========================================
           TEMPORAL DEBT DASHBOARD
           ======================================== */

        .temporal-debt-panel {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border-left: 4px solid #888;
            transition: border-left-color 0.3s ease;
        }

        .temporal-debt-panel.pass {
            border-left-color: #00ff88;
        }

        .temporal-debt-panel.acceptable {
            border-left-color: #00d9ff;
        }

        .temporal-debt-panel.misaligned {
            border-left-color: #ff9500;
        }

        .temporal-debt-panel.catastrophic {
            border-left-color: #ff3b30;
        }

        .debt-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .debt-header h3 {
            color: #00d9ff;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .debt-verdict {
            font-size: 1.1rem;
            font-weight: bold;
            padding: 8px 16px;
            border-radius: 4px;
            background: #1a1a1a;
        }

        .debt-verdict.pass {
            color: #00ff88;
        }

        .debt-verdict.acceptable {
            color: #00d9ff;
        }

        .debt-verdict.misaligned {
            color: #ff9500;
        }

        .debt-verdict.catastrophic {
            color: #ff3b30;
            animation: pulse-debt 1s infinite;
        }

        @keyframes pulse-debt {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .debt-main {
            text-align: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #1a1a1a;
            border-radius: 8px;
        }

        .debt-value {
            font-size: 4rem;
            font-weight: bold;
            color: #fff;
            line-height: 1;
            font-variant-numeric: tabular-nums;
        }

        .debt-label {
            font-size: 1rem;
            color: #888;
            margin-top: 8px;
        }

        .debt-breakdown {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .debt-stat {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            text-align: center;
            border-left: 3px solid;
        }

        .debt-stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            margin-bottom: 5px;
            font-variant-numeric: tabular-nums;
        }

        .debt-stat-label {
            font-size: 0.85rem;
            color: #888;
        }

        .debt-stat.emergency {
            border-left-color: #ff3b30;
        }

        .debt-stat.emergency .debt-stat-value {
            color: #ff3b30;
        }

        .debt-stat.scheduled {
            border-left-color: #00ff88;
        }

        .debt-stat.scheduled .debt-stat-value {
            color: #00ff88;
        }

        .debt-stat.total {
            border-left-color: #00d9ff;
        }

        .debt-stat.total .debt-stat-value {
            color: #00d9ff;
        }

        .verdict-legend {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }

        .verdict-item {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.85rem;
        }

        .verdict-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .verdict-dot.pass {
            background: #00ff88;
        }

        .verdict-dot.acceptable {
            background: #00d9ff;
        }

        .verdict-dot.misaligned {
            background: #ff9500;
        }

        .verdict-dot.catastrophic {
            background: #ff3b30;
        }

        /* Configuration Panel */
        .config-panel {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
        }

        .config-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .config-item {
            display: flex;
            flex-direction: column;
        }

        .config-item label {
            font-size: 0.9rem;
            color: #ccc;
            margin-bottom: 5px;
        }

        .config-item input,
        .config-item select {
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #555;
            border-radius: 4px;
            padding: 8px;
            font-size: 0.9rem;
        }

        /* ========================================
           PHASE 1: Schedule Parser Styles
           ======================================== */

        .schedule-input-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            border-left: 4px solid #00ff88;
        }

        .schedule-input-panel h4 {
            color: #00ff88;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .schedule-input-panel textarea {
            width: 100%;
            padding: 12px;
            background: #1a1a1a;
            border: 1px solid #444;
            border-radius: 4px;
            color: #e0e0e0;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
            resize: vertical;
            min-height: 120px;
        }

        .schedule-input-panel textarea::placeholder {
            color: #666;
        }

        .parse-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .parse-status {
            margin-top: 10px;
            padding: 10px;
            border-radius: 4px;
            font-size: 0.9rem;
            display: none;
        }

        .parse-status.success {
            background: #00ff8822;
            color: #00ff88;
            border: 1px solid #00ff8844;
        }

        .parse-status.error {
            background: #ff3b3022;
            color: #ff3b30;
            border: 1px solid #ff3b3044;
        }

        .parse-status.warning {
            background: #ff950022;
            color: #ff9500;
            border: 1px solid #ff950044;
        }

        .parsed-schedule {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            display: none;
            border-left: 4px solid #00d9ff;
        }

        .parsed-schedule h4 {
            color: #00d9ff;
            margin-bottom: 15px;
        }

        .schedule-breakdown {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            margin-bottom: 15px;
        }

        .schedule-day {
            padding: 10px 0;
            border-bottom: 1px solid #333;
        }

        .schedule-day:last-child {
            border-bottom: none;
        }

        .schedule-day strong {
            color: #00d9ff;
        }

        .schedule-day .time {
            color: #00ff88;
            font-family: monospace;
        }

        .schedule-day .breaks {
            color: #ff9500;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .schedule-day .flags {
            color: #888;
            font-size: 0.85rem;
            margin-top: 4px;
        }

        .example-schedules {
            display: flex;
            gap: 10px;
            margin-top: 10px;
            flex-wrap: wrap;
        }

        .example-btn {
            padding: 8px 16px;
            font-size: 0.9rem;
            background: #1a1a1a;
            color: #00d9ff;
            border: 1px solid #00d9ff;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .example-btn:hover {
            background: #00d9ff22;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            padding: 20px;
            background: #2a2a2a;
            border-radius: 8px;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 24px;
            font-size: 1rem;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
        }

        .btn-primary {
            background: #00d9ff;
            color: #1a1a1a;
        }

        .btn-warning {
            background: #ff9500;
            color: #1a1a1a;
        }

        .btn-danger {
            background: #ff3b30;
            color: white;
        }

        .btn-primary:hover {
            background: #00b8d9;
        }

        .btn-warning:hover {
            background: #e08500;
        }

        .btn-danger:hover {
            background: #d32f2f;
        }

        .schedule-selector {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .schedule-selector label {
            color: #888;
        }

        .schedule-selector select {
            padding: 8px 16px;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 1rem;
        }

        .time-selector {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 200px;
        }

        .time-selector label {
            color: #888;
            font-size: 0.9rem;
        }

        .time-selector input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: #00d9ff;
        }

        #startTimeValue {
            color: #00d9ff;
            font-weight: bold;
        }

        .speed-selector {
            display: flex;
            flex-direction: column;
            gap: 5px;
            min-width: 180px;
        }

        .speed-selector label {
            color: #888;
            font-size: 0.9rem;
        }

        .speed-selector select {
            padding: 8px 12px;
            background: #1a1a1a;
            color: #e0e0e0;
            border: 1px solid #444;
            border-radius: 4px;
            font-size: 0.95rem;
            cursor: pointer;
        }

        #speedValue {
            color: #ff9500;
            font-weight: bold;
        }

        /* Simulation Area */
        .simulation-area {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-container {
            background: #0a0a0a;
            border-radius: 8px;
            padding: 20px;
            border: 2px solid #333;
        }

        #eara-canvas {
            width: 100%;
            display: block;
            border-radius: 4px;
        }

        /* Stats Panel */
        .stats-panel {
            background: #2a2a2a;
            border-radius: 8px;
            padding: 20px;
            max-height: 600px;
            overflow-y: auto;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            padding: 8px 0;
            border-bottom: 1px solid #444;
        }

        .stat-label {
            color: #ccc;
            font-size: 0.9rem;
        }

        .stat-value {
            font-weight: bold;
            color: #00ff88;
        }

        .stat-value.warning {
            color: #ff9500;
        }

        .stat-value.critical {
            color: #ff3b30;
        }

        .debug-item {
            background: #2a2a2a;
            padding: 10px;
            margin-top: 5px;
            border-radius: 4px;
            border-left: 3px solid #00d9ff;
        }

        .debug-item .stat-label {
            color: #00d9ff;
            font-size: 0.85rem;
        }

        /* Metrics Panel */
        .metrics-panel {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .metrics-panel h3 {
            color: #00d9ff;
            margin-bottom: 15px;
        }

        #workerMetrics {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .worker-metric {
            background: #1a1a1a;
            padding: 15px;
            border-radius: 4px;
            border-left: 4px solid;
            transition: all 0.3s ease;
        }

        .worker-metric.optimal {
            border-color: #00ff88;
        }

        .worker-metric.degraded {
            border-color: #ff9500;
        }

        .worker-metric.critical {
            border-color: #ff3b30;
        }

        .worker-metric.shutdown {
            border-color: #8b0000;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .worker-metric h4 {
            margin-bottom: 8px;
            font-size: 0.9rem;
            color: #888;
        }

        .worker-metric .value {
            font-size: 1.5rem;
            font-weight: bold;
            margin-bottom: 5px;
        }

        .worker-metric .label {
            font-size: 0.85rem;
            color: #666;
        }

        /* Financial Summary */
        .financial-summary {
            background: #1a2332;
            border: 2px solid #00d9ff;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }

        .summary-title {
            font-size: 1.3rem;
            color: #00d9ff;
            margin-bottom: 15px;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .summary-section h4 {
            color: #ccc;
            margin-bottom: 10px;
        }

        .summary-item {
            margin-bottom: 10px;
        }

        .summary-item .label {
            color: #aaa;
        }

        .summary-item .value {
            font-weight: bold;
            margin-left: 10px;
        }

        .summary-item .value.loss {
            color: #ff3b30;
        }

        .summary-item .value.warning {
            color: #ff9500;
        }

        .summary-item .value.success {
            color: #00ff88;
        }

        .summary-item .value.info {
            color: #00d9ff;
        }

        /* Legend */
        .legend {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }

        .legend h4 {
            color: #00d9ff;
            margin-bottom: 15px;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 10px;
        }

        .color-box {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            border: 2px solid #444;
        }

        .color-box.optimal {
            background: #00ff88;
        }

        .color-box.degraded {
            background: #ff9500;
        }

        .color-box.critical {
            background: #ff3b30;
        }

        .color-box.shutdown {
            background: #8b0000;
        }

        /* === COMPARISON MODE STYLES === */
        #toggleComparisonMode {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }

        #toggleComparisonMode:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
        }

        #comparisonContainer {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px auto;
            padding: 20px;
            max-width: 1600px;
            background: #f5f5f5;
            border-radius: 12px;
        }

        .sim-panel {
            background: white;
            border-radius: 12px;
            padding: 20px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
            border: 3px solid;
        }

        .sprint-panel {
            border-color: #10b981;
        }

        .traditional-panel {
            border-color: #ef4444;
        }

        .panel-header {
            text-align: center;
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 15px;
            padding: 10px;
            border-radius: 8px;
        }

        .sprint-header {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
        }

        .traditional-header {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .metric-row {
            display: grid;
            grid-template-columns: 2fr 1fr;
            padding: 8px;
            border-bottom: 1px solid #e5e7eb;
            font-size: 14px;
        }

        .metric-label {
            font-weight: 500;
            color: #6b7280;
        }

        .metric-value {
            text-align: right;
            font-weight: bold;
        }

        #deltaMetrics {
            grid-column: 1 / -1;
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
            padding: 20px;
            border-radius: 12px;
            color: white;
        }

        #deltaMetrics h3 {
            margin: 0 0 15px 0;
            font-size: 22px;
            text-align: center;
        }

        .delta-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .delta-card {
            background: rgba(255, 255, 255, 0.2);
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .delta-value {
            font-size: 28px;
            font-weight: bold;
            margin: 5px 0;
        }

        .delta-label {
            font-size: 14px;
            opacity: 0.9;
        }

        .positive-delta {
            color: #10b981;
        }

        .negative-delta {
            color: #ef4444;
        }

        .worker-mini-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
            gap: 8px;
            margin-top: 10px;
        }

        .worker-mini-card {
            padding: 8px;
            border-radius: 6px;
            text-align: center;
            font-size: 11px;
            font-weight: bold;
        }

        /* Mode toggle visibility */
        body.comparison-mode #mainSimulation {
            display: none;
        }

        body.comparison-mode #comparisonContainer {
            display: grid;
        }

        body:not(.comparison-mode) #comparisonContainer {
            display: none;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üéØ EARA Core v0.5.2</h1>
            <p class="subtitle">Multi-Day Simulation + Temporal Debt Tracking</p>
            <div>
                <span class="badge">Phase 1: Schedule Parser ‚úì</span>
                <span class="badge">Phase 1: Circadian Integration ‚úì</span>
                <span class="badge">Phase 2: Financial Tracking ‚úì</span>
                <span class="badge critical">v0.5.1: Critical Bug Fixes ‚úì</span>
            </div>
            <p style="color: #888; font-size: 0.9rem; margin-top: 10px;">
                ‚è±Ô∏è Simulation time = Real-world time (1:1 speed)
            </p>
        </header>

        <!-- Main Simulation Container (for toggle) -->
        <div id="mainSimulation">


            <!-- ========================================
             PHASE 2: Financial Dashboard
             ======================================== -->

            <div class="financial-dashboard">
                <div class="financial-card loss">
                    <div class="financial-value" id="totalLoss">$0.00</div>
                    <div class="financial-label">Total Financial Loss</div>
                    <div class="financial-details" id="lossDetails">Per shift productivity degradation</div>
                </div>
                <div class="financial-card zombie">
                    <div class="financial-value" id="zombieCost">$0.00</div>
                    <div class="financial-label">Zombie Labor Cost</div>
                    <div class="financial-details" id="zombieDetails">Hours paid at Œ≥ ‚â• 0.7</div>
                </div>
                <div class="financial-card">
                    <div class="financial-value" id="temporalDebt">$0.00</div>
                    <div class="financial-label">Temporal Debt</div>
                    <div class="financial-details" id="debtDetails">Emergency shutdown costs</div>
                </div>
            </div>

            <!-- ========================================
             PHASE 2: Configuration Panel
             ======================================== -->

            <div class="config-panel">
                <h3 style="margin-bottom: 15px; color: #00d9ff;">üìä Financial Parameters</h3>
                <div class="config-grid">
                    <div class="config-item">
                        <label>Hourly Wage ($)</label>
                        <input type="number" id="hourlyWage" value="15" min="7" max="50" step="0.25">
                    </div>
                    <div class="config-item">
                        <label>Workers per Shift</label>
                        <input type="number" id="workersPerShift" value="8" min="1" max="20">
                    </div>
                    <div class="config-item">
                        <label>Error Cost per Incident ($)</label>
                        <input type="number" id="errorCost" value="35" min="5" max="200">
                    </div>
                    <div class="config-item">
                        <label>Annual Work Days</label>
                        <input type="number" id="annualDays" value="250" min="200" max="365">
                    </div>
                </div>
            </div>

            <!-- ========================================
             PHASE 1: Schedule Parser UI
             ======================================== -->

            <div class="schedule-input-panel">
                <h4>üóìÔ∏è Paste Your Schedule</h4>
                <textarea id="scheduleInput" placeholder="Example:
Mon: 9am-7pm (1hr lunch at noon)
Tue: Flex 10-8 with breaks
Wed: Off but emails/calls
Thu: 9-5 normal
Fri: Night shift 10pm-6am" rows="6"></textarea>

                <div class="example-schedules">
                    <button class="example-btn" id="example1">üìã Standard 9-5 (M-F)</button>
                    <button class="example-btn" id="example2">üåÖ Early Shift (4am start)</button>
                    <button class="example-btn" id="example3">üåô Night Shift (10pm-6am)</button>
                </div>

                <div class="parse-controls">
                    <button id="parseBtn" style="background: #00ff88; color: #1a1a1a;">
                        Parse & Load Schedule
                    </button>

                    <button id="clearScheduleBtn" style="background: #666; color: white;">
                        Clear
                    </button>
                </div>

                <div id="parseStatus" class="parse-status"></div>
            </div>

            <div id="parsedScheduleDisplay" class="parsed-schedule">
                <h4>‚úÖ Detected Schedule</h4>
                <div id="scheduleBreakdown" class="schedule-breakdown"></div>
                <button id="runCustomSim" style="
                background: #00d9ff;
                color: #1a1a1a;
                padding: 12px 24px;
                font-size: 1rem;
                border: none;
                border-radius: 4px;
                cursor: pointer;
                font-weight: 600;
            ">Run Simulation with This Schedule</button>
            </div>

            <!-- ========================================
             Controls
             ======================================== -->

            <div class="controls">
                <button id="startBtn" class="btn-primary">‚ñ∂Ô∏è Start Simulation</button>
                <button id="pauseBtn" class="btn-warning">‚è∏Ô∏è Pause</button>
                <button id="resetBtn" class="btn-danger">üîÑ Reset</button>
                <button id="exportBtn" class="btn-primary">üìä Export Financial Report</button>

                <div class="schedule-selector">
                    <label>Schedule Type:</label>
                    <select id="scheduleSelect">
                        <option value="sprint">4hr Sprint (Optimal)</option>
                        <option value="traditional">8hr Traditional</option>
                        <option value="stress">6hr Stress Test</option>
                    </select>
                </div>

                <div class="time-selector">
                    <label>Start Time: <span id="startTimeValue">08:00</span></label>
                    <input type="range" id="startTimeSlider" min="0" max="23" value="8" step="1">
                </div>

                <div class="speed-selector">
                    <label>‚ö° Speed: <span id="speedValue">1√ó</span></label>
                    <select id="speedSelect">
                        <option value="1">1√ó (Real-time)</option>
                        <option value="10">10√ó (Fast)</option>
                        <option value="60" selected>60√ó (Very Fast)</option>
                        <option value="100">100√ó (Ultra Fast)</option>
                        <option value="300">300√ó (Instant)</option>
                    </select>
                </div>
            </div>

            <!-- ========================================
             Simulation Area (Canvas + Stats)
             ======================================== -->

            <div class="simulation-area">
                <div class="canvas-container">
                    <canvas id="eara-canvas"></canvas>
                </div>

                <!-- Real-time Stats Panel -->
                <div class="stats-panel">
                    <h3 style="color: #00d9ff; margin-bottom: 15px;">üìà Live Metrics</h3>

                    <div class="stat-item">
                        <span class="stat-label">‚è±Ô∏è Time (Sim | Real | Speed)</span>
                        <span class="stat-value" id="elapsedTime">00:00:00 (Day 1) | Real: 00:00 | Speed: 1√ó</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Average Œ≥ Level</span>
                        <span class="stat-value" id="avgGamma">0.00</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Workers in Critical State</span>
                        <span class="stat-value critical" id="criticalWorkers">0</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Average Capacity</span>
                        <span class="stat-value" id="avgCapacity">100%</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Emergency Shutdowns</span>
                        <span class="stat-value critical" id="emergencyCount">0</span>
                    </div>

                    <!-- DEBUG PANEL: Œ≥ Accumulation Rate -->
                    <div class="stat-item debug-item">
                        <span class="stat-label">üî¨ dŒ≥/dt (Fatigue Rate)</span>
                        <span class="stat-value" id="gammaRate">+0.000/min</span>
                    </div>

                    <div class="stat-item debug-item">
                        <span class="stat-label">üî¨ Expected Œ≥ @ 4hrs</span>
                        <span class="stat-value" id="gamma4hr">0.00</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Zombie Labor Hours</span>
                        <span class="stat-value warning" id="zombieHours">0.0</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Error Events</span>
                        <span class="stat-value critical" id="errorEvents">0</span>
                    </div>

                    <div class="stat-item">
                        <span class="stat-label">Current Loss Rate</span>
                        <span class="stat-value critical" id="lossRate">$0.00/hr</span>
                    </div>
                </div>
            </div>

            <!-- ========================================
             Individual Worker Metrics
             ======================================== -->

            <div class="metrics-panel">
                <h3>Individual Worker Status</h3>
                <div id="workerMetrics"></div>
            </div>

            <!-- ========================================
             TEMPORAL DEBT DASHBOARD
             ======================================== -->

            <div class="temporal-debt-panel pass" id="temporalDebtPanel">
                <div class="debt-header">
                    <h3>
                        ‚öñÔ∏è Temporal Debt Accumulator
                    </h3>
                    <div class="debt-verdict pass" id="debtVerdict">PASS</div>
                </div>

                <div class="debt-main">
                    <div class="debt-value" id="debtValue">0.0</div>
                    <div class="debt-label">seconds of temporal debt</div>
                </div>

                <div class="debt-breakdown">
                    <div class="debt-stat emergency">
                        <div class="debt-stat-value" id="emergencyShutdowns">0</div>
                        <div class="debt-stat-label">Emergency Shutdowns</div>
                    </div>
                    <div class="debt-stat scheduled">
                        <div class="debt-stat-value" id="scheduledRests">0</div>
                        <div class="debt-stat-label">Scheduled Rests</div>
                    </div>
                    <div class="debt-stat total">
                        <div class="debt-stat-value" id="totalRecoveries">0</div>
                        <div class="debt-stat-label">Total Recoveries</div>
                    </div>
                </div>

                <div class="verdict-legend">
                    <div class="verdict-item">
                        <div class="verdict-dot pass"></div>
                        <span>PASS (&lt; 5s)</span>
                    </div>
                    <div class="verdict-item">
                        <div class="verdict-dot acceptable"></div>
                        <span>ACCEPTABLE (5-10s)</span>
                    </div>
                    <div class="verdict-item">
                        <div class="verdict-dot misaligned"></div>
                        <span>MISALIGNED (10-20s)</span>
                    </div>
                    <div class="verdict-item">
                        <div class="verdict-dot catastrophic"></div>
                        <span>CATASTROPHIC (&gt; 20s)</span>
                    </div>
                </div>
            </div>

            <!-- ========================================
             Financial Impact Summary
             ======================================== -->

            <div class="financial-summary">
                <div class="summary-title">üí∞ Financial Impact Analysis</div>
                <div class="summary-grid">
                    <div class="summary-section">
                        <h4>Current Shift Impact</h4>
                        <div class="summary-item">
                            <span class="label">Productivity Loss:</span>
                            <span class="value loss" id="shiftProductivity">$0.00</span>
                        </div>
                        <div class="summary-item">
                            <span class="label">Error Costs:</span>
                            <span class="value warning" id="shiftErrors">$0.00</span>
                        </div>
                        <div class="summary-item">
                            <span class="label">Temporal Debt:</span>
                            <span class="value warning" id="shiftDebt">$0.00</span>
                        </div>
                    </div>
                    <div class="summary-section">
                        <h4>Annual Projections</h4>
                        <div class="summary-item">
                            <span class="label">Annual Loss:</span>
                            <span class="value loss" id="annualLoss">$0.00</span>
                        </div>
                        <div class="summary-item">
                            <span class="label">4x4 Savings:</span>
                            <span class="value success" id="optimizedSavings">$0.00</span>
                        </div>
                        <div class="summary-item">
                            <span class="label">ROI Potential:</span>
                            <span class="value info" id="roiPotential">0%</span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ========================================
             Legend
             ======================================== -->

            <div class="legend">
                <h4>Worker States</h4>
                <div class="legend-item">
                    <span class="color-box optimal"></span>
                    <span>Optimal (Œ≥ < 0.3) - High capacity, low risk</span>
                </div>
                <div class="legend-item">
                    <span class="color-box degraded"></span>
                    <span>Degraded (0.3 ‚â§ Œ≥ < 0.7) - Declining capacity</span>
                </div>
                <div class="legend-item">
                    <span class="color-box critical"></span>
                    <span>Critical (Œ≥ ‚â• 0.7) - High accident risk</span>
                </div>
                <div class="legend-item">
                    <span class="color-box shutdown"></span>
                    <span>Emergency Shutdown (Œ≥ ‚â• 1.0) - Immediate intervention required</span>
                </div>
            </div>
        </div>


    </div>
    <!-- End Main Simulation -->

    <!-- Comparison Mode Toggle Button -->
    <button id="toggleComparisonMode">üîÑ Enable Comparison Mode</button>

    <!-- Comparison Container -->
    <div id="comparisonContainer">

        <!-- Sprint Panel (Left) -->
        <div class="sim-panel sprint-panel">
            <div class="panel-header sprint-header">
                ‚ö° 4-Hour Sprint Schedule
            </div>

            <div class="metric-row">
                <span class="metric-label">‚è±Ô∏è Elapsed Time</span>
                <span class="metric-value" id="sprintTime">00:00:00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üìä Average Œ≥</span>
                <span class="metric-value" id="sprintAvgGamma">0.000</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí™ Average Capacity</span>
                <span class="metric-value" id="sprintAvgCapacity">100%</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üö® Critical Workers</span>
                <span class="metric-value" id="sprintCritical">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üõë Emergency Shutdowns</span>
                <span class="metric-value" id="sprintShutdowns">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üßü Zombie Labor Hours</span>
                <span class="metric-value" id="sprintZombieHours">0.0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">‚ö†Ô∏è Error Events</span>
                <span class="metric-value" id="sprintErrors">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí∞ Total Loss</span>
                <span class="metric-value" id="sprintTotalLoss">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üìâ Productivity Loss</span>
                <span class="metric-value" id="sprintProductivityLoss">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí∏ Error Costs</span>
                <span class="metric-value" id="sprintErrorCosts">$0.00</span>
            </div>

            <h4 style="margin-top: 20px; color: #059669;">Worker Status Grid</h4>
            <div class="worker-mini-grid" id="sprintWorkers"></div>
        </div>

        <!-- Traditional Panel (Right) -->
        <div class="sim-panel traditional-panel">
            <div class="panel-header traditional-header">
                üïê 8-Hour Traditional Schedule
            </div>

            <div class="metric-row">
                <span class="metric-label">‚è±Ô∏è Elapsed Time</span>
                <span class="metric-value" id="traditionalTime">00:00:00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üìä Average Œ≥</span>
                <span class="metric-value" id="traditionalAvgGamma">0.000</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí™ Average Capacity</span>
                <span class="metric-value" id="traditionalAvgCapacity">100%</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üö® Critical Workers</span>
                <span class="metric-value" id="traditionalCritical">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üõë Emergency Shutdowns</span>
                <span class="metric-value" id="traditionalShutdowns">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üßü Zombie Labor Hours</span>
                <span class="metric-value" id="traditionalZombieHours">0.0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">‚ö†Ô∏è Error Events</span>
                <span class="metric-value" id="traditionalErrors">0</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí∞ Total Loss</span>
                <span class="metric-value" id="traditionalTotalLoss">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üìâ Productivity Loss</span>
                <span class="metric-value" id="traditionalProductivityLoss">$0.00</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">üí∏ Error Costs</span>
                <span class="metric-value" id="traditionalErrorCosts">$0.00</span>
            </div>

            <h4 style="margin-top: 20px; color: #dc2626;">Worker Status Grid</h4>
            <div class="worker-mini-grid" id="traditionalWorkers"></div>
        </div>

        <!-- Delta Metrics Panel (Bottom) -->
        <div id="deltaMetrics">
            <h3>üìä Comparative Analysis: Traditional vs Sprint</h3>
            <div class="delta-grid">
                <div class="delta-card">
                    <div class="delta-label">Œ≥ Difference</div>
                    <div class="delta-value" id="deltaGamma">+0.000</div>
                    <small>Higher = Worse fatigue</small>
                </div>
                <div class="delta-card">
                    <div class="delta-label">Additional Cost</div>
                    <div class="delta-value" id="deltaLoss">$0.00</div>
                    <small>Traditional excess loss</small>
                </div>
                <div class="delta-card">
                    <div class="delta-label">Zombie Labor Gap</div>
                    <div class="delta-value" id="deltaZombie">+0.0 hrs</div>
                    <small>Extra degraded hours</small>
                </div>
                <div class="delta-card">
                    <div class="delta-label">Shutdown Difference</div>
                    <div class="delta-value" id="deltaShutdowns">+0</div>
                    <small>Additional emergencies</small>
                </div>
                <div class="delta-card">
                    <div class="delta-label">Annual Savings Potential</div>
                    <div class="delta-value positive-delta" id="annualSavings">$0</div>
                    <small>By switching to Sprint</small>
                </div>
            </div>

            <div style="margin-top: 20px; text-align: center;">
                <button id="comparisonStart"
                    style="background: #10b981; color: white; padding: 10px 20px; margin: 5px; border: none; border-radius: 6px; font-size: 16px; cursor: pointer;">‚ñ∂Ô∏è
                    Start Comparison</button>
                <button id="comparisonPause"
                    style="background: #f59e0b; color: white; padding: 10px 20px; margin: 5px; border: none; border-radius: 6px; font-size: 16px; cursor: pointer;">‚è∏Ô∏è
                    Pause</button>
                <button id="comparisonReset"
                    style="background: #6b7280; color: white; padding: 10px 20px; margin: 5px; border: none; border-radius: 6px; font-size: 16px; cursor: pointer;">üîÑ
                    Reset</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // ========================================================================
        // CONFIGURATION
        // ========================================================================

        const CONFIG = {
            canvas: {
                width: 1000,
                height: 600
            },

            colors: {
                optimal: '#00ff88',
                degraded: '#ff9500',
                critical: '#ff3b30',
                shutdown: '#8b0000'
            },

            schedules: {
                sprint: [
                    { type: 'work', duration: 240 },  // 4hr work
                    { type: 'rest', duration: 120 }   // 2hr rest
                ],
                traditional: [
                    { type: 'work', duration: 480 },  // 8hr work
                    { type: 'rest', duration: 960 }   // 16hr rest
                ],
                stress: [
                    { type: 'work', duration: 360 },  // 6hr work (hits entropy wall)
                    { type: 'rest', duration: 1080 }  // 18hr rest
                ]
            }
        };

        // ========================================================================
        // PHASE 1: SCHEDULE PARSER MODULE
        // ========================================================================

        class ScheduleParser {
            constructor(config = {}) {
                // LLM ENDPOINT (Currently Unused - Reserved for v0.6)
                // If local regex parsing confidence < 70%, could fallback to LLM for fuzzy interpretation
                // Example: "work mornings this week" ‚Üí structured schedule
                // Requires: Local Ollama server at localhost:52625 with llama3 model
                // Status: Disabled for now, local-only parsing works well for explicit formats
                this.llmEndpoint = config.llmEndpoint || 'http://localhost:52625/v1';
                this.llmModel = config.llmModel || 'llama3';
                this.useLLM = config.useLLM || false;
                this.minConfidence = config.minConfidence || 0.7;
            }

            async parse(text) {
                if (!text || text.trim().length === 0) {
                    return { error: 'Empty input', schedule: [], confidence: 0 };
                }

                try {
                    const localResult = this.localParse(text);
                    return localResult;
                } catch (error) {
                    console.error('Parse error:', error);
                    return {
                        error: error.message,
                        schedule: [],
                        confidence: 0,
                        source: 'error'
                    };
                }
            }

            localParse(text) {
                const lines = text.split('\n').filter(line => line.trim());
                const schedule = [];

                lines.forEach((line, index) => {
                    const dayMatch = this.extractDay(line);

                    if (dayMatch && /\b(off|rest|vacation|holiday)\b/i.test(line)) {
                        return;
                    }

                    const times = this.extractTimes(line);
                    const breaks = this.extractBreaks(line);
                    const flags = this.extractFlags(line);

                    if (dayMatch && times.length >= 2) {
                        schedule.push({
                            day: dayMatch,
                            start: times[0],
                            end: times[1],
                            breaks: breaks,
                            nightShift: flags.nightShift,
                            flexible: flags.flexible,
                            offButActive: flags.offButActive,
                            rawLine: line
                        });
                    }
                });

                const confidence = this.calculateConfidence(schedule, lines.length);

                return { schedule, confidence, source: 'local' };
            }

            extractDay(line) {
                const days = {
                    'mon': 'Monday', 'tue': 'Tuesday', 'wed': 'Wednesday',
                    'thu': 'Thursday', 'fri': 'Friday', 'sat': 'Saturday', 'sun': 'Sunday',
                    'monday': 'Monday', 'tuesday': 'Tuesday', 'wednesday': 'Wednesday',
                    'thursday': 'Thursday', 'friday': 'Friday', 'saturday': 'Saturday', 'sunday': 'Sunday'
                };

                const lower = line.toLowerCase();
                for (const [abbr, full] of Object.entries(days)) {
                    const regex = new RegExp(`\\b${abbr}\\b`, 'i');
                    if (regex.test(lower)) return full;
                }
                return null;
            }

            extractTimes(line) {
                const times = [];

                const pattern12hr = /(\d{1,2})(?::?(\d{2}))?\s*(am|pm)\s*[-‚Äì‚Äîto]+\s*(\d{1,2})(?::?(\d{2}))?\s*(am|pm)/gi;
                let match = pattern12hr.exec(line);

                if (match) {
                    let startMin = match[2];
                    let endMin = match[5];

                    if (startMin && startMin.length > 2) {
                        startMin = startMin.substring(startMin.length - 2);
                    }
                    if (endMin && endMin.length > 2) {
                        endMin = endMin.substring(endMin.length - 2);
                    }

                    const start = this.convertTo24Hour(
                        parseInt(match[1]),
                        parseInt(startMin || 0),
                        match[3]
                    );
                    const end = this.convertTo24Hour(
                        parseInt(match[4]),
                        parseInt(endMin || 0),
                        match[6]
                    );
                    times.push(start, end);
                    return times;
                }

                const pattern24hr = /(\d{1,2}):(\d{2})\s*[-‚Äì‚Äîto]+\s*(\d{1,2}):(\d{2})/g;
                match = pattern24hr.exec(line);

                if (match) {
                    times.push(
                        parseInt(match[1]) + (parseInt(match[2]) / 60),
                        parseInt(match[3]) + (parseInt(match[4]) / 60)
                    );
                    return times;
                }

                const patternHours = /(\d{1,2})\s*[-‚Äì‚Äîto]+\s*(\d{1,2})/g;
                match = patternHours.exec(line);

                if (match && times.length === 0) {
                    let start = parseInt(match[1]);
                    let end = parseInt(match[2]);
                    if (end < start) end += 12;
                    times.push(start, end);
                }

                return times;
            }

            convertTo24Hour(hour, minute, meridiem) {
                let h = hour;
                const m = meridiem.toLowerCase();
                if (m === 'pm' && h !== 12) h += 12;
                if (m === 'am' && h === 12) h = 0;
                return h + (minute / 60);
            }

            extractBreaks(line) {
                const breaks = [];

                const breakPatternWithTime = /(\d+)\s*(hr|hour|min|minute)s?\s+(?:lunch|break)\s+(?:at\s+)?(\d{1,2})(?::(\d{2}))?\s*(am|pm)?/gi;
                let match;

                while ((match = breakPatternWithTime.exec(line)) !== null) {
                    const duration = match[2].startsWith('hr') ? parseInt(match[1]) * 60 : parseInt(match[1]);
                    let time = match[5] ?
                        this.convertTo24Hour(parseInt(match[3]), parseInt(match[4] || 0), match[5]) :
                        parseInt(match[3]);
                    breaks.push({ duration, time });
                }

                const breakPatternNoTime = /\((\d+)\s*(hr|hour|min|minute)s?\s+break\)/gi;

                while ((match = breakPatternNoTime.exec(line)) !== null) {
                    const duration = match[2].startsWith('hr') ? parseInt(match[1]) * 60 : parseInt(match[1]);
                    breaks.push({ duration, time: null });
                }

                return breaks;
            }

            extractFlags(line) {
                const lower = line.toLowerCase();
                return {
                    nightShift: lower.includes('night') || lower.includes('overnight') ||
                        /\d{1,2}\s*pm\s*[-‚Äì‚Äî]\s*\d{1,2}\s*am/.test(lower),
                    flexible: lower.includes('flex'),
                    offButActive: (lower.includes('off') || lower.includes('rest')) &&
                        (lower.includes('but') || lower.includes('email') || lower.includes('call'))
                };
            }

            calculateConfidence(schedule, totalLines) {
                if (schedule.length === 0) return 0;
                let score = (schedule.length / Math.max(totalLines, 1)) * 0.4;
                schedule.forEach(day => {
                    let dayScore = 0;
                    if (day.day) dayScore += 0.3;
                    if (day.start !== undefined && day.end !== undefined) dayScore += 0.5;
                    if (day.breaks.length > 0) dayScore += 0.2;
                    score += (dayScore / schedule.length) * 0.6;
                });
                return Math.min(score, 1.0);
            }

            toWorkerConfigs(parseResult) {
                const configs = [];
                const warnings = [];

                parseResult.schedule.forEach((day) => {
                    const shiftDuration = (day.end - day.start) * 60;
                    const breakDuration = day.breaks.reduce((sum, b) => sum + b.duration, 0);
                    const workDuration = shiftDuration - breakDuration;

                    // EDGE CASE VALIDATION
                    // 1. Check for dangerously long shifts (>16 hours)
                    if (shiftDuration > 960) {
                        warnings.push(`‚ö†Ô∏è ${day.day}: ${(shiftDuration / 60).toFixed(1)}hr shift exceeds safe maximum (16hr). Risk of severe fatigue.`);
                    }

                    // 2. Check for 24-hour shifts
                    if (shiftDuration >= 1440) {
                        warnings.push(`üö® ${day.day}: 24-hour shift detected! Workers will hit emergency shutdown. Consider splitting into multiple days.`);
                    }

                    // 3. Check for insufficient breaks
                    const breakRatio = breakDuration / shiftDuration;
                    if (shiftDuration > 480 && breakRatio < 0.05) {
                        warnings.push(`‚ö†Ô∏è ${day.day}: ${(shiftDuration / 60).toFixed(1)}hr shift with only ${breakDuration}min breaks (${(breakRatio * 100).toFixed(1)}%). Recommend 30min+ per 8 hours.`);
                    }

                    // 4. Check for negative duration (end before start)
                    if (day.end < day.start) {
                        warnings.push(`‚ùå ${day.day}: End time (${day.end}:00) before start time (${day.start}:00). This is an overnight shift - please clarify.`);
                    }

                    // 5. Check for very short shifts (<2 hours)
                    if (workDuration < 120) {
                        warnings.push(`‚ÑπÔ∏è ${day.day}: ${(workDuration / 60).toFixed(1)}hr work time is very short. Is this intentional?`);
                    }

                    const blocks = this.splitIntoBlocks(day.start, day.end, day.breaks);
                    const earaSchedule = blocks.map(block => ({
                        type: block.type,
                        duration: block.duration,
                        startHour: block.startHour
                    }));

                    configs.push({
                        day: day.day,
                        schedule: earaSchedule,
                        startHour: day.start,
                        nightShift: day.nightShift,
                        metadata: {
                            totalWork: workDuration,
                            totalBreaks: breakDuration,
                            totalShift: shiftDuration,
                            flexible: day.flexible,
                            offButActive: day.offButActive,
                            rawLine: day.rawLine,
                            warnings: warnings.length > 0 ? warnings : null
                        }
                    });
                });

                // Store warnings for display
                if (warnings.length > 0) {
                    console.warn('‚ö†Ô∏è Schedule Validation Warnings:', warnings);
                }

                return { configs, warnings };
            }

            splitIntoBlocks(start, end, breaks) {
                const blocks = [];
                let currentTime = start;

                const breaksWithTime = breaks.filter(b => b.time !== null).sort((a, b) => a.time - b.time);
                const breaksWithoutTime = breaks.filter(b => b.time === null);

                if (breaksWithoutTime.length > 0) {
                    const totalWorkTime = end - start;
                    const totalBreakDuration = breaksWithoutTime.reduce((sum, b) => sum + b.duration, 0) / 60;
                    const netWorkTime = totalWorkTime - totalBreakDuration;

                    const midPoint = start + (netWorkTime / 2);
                    breaksWithoutTime.forEach(brk => {
                        breaksWithTime.push({ duration: brk.duration, time: midPoint });
                    });
                    breaksWithTime.sort((a, b) => a.time - b.time);
                }

                breaksWithTime.forEach(brk => {
                    if (brk.time > currentTime) {
                        blocks.push({
                            type: 'work',
                            duration: (brk.time - currentTime) * 60,
                            startHour: currentTime
                        });
                    }
                    blocks.push({
                        type: 'rest',
                        duration: brk.duration,
                        startHour: brk.time
                    });
                    currentTime = brk.time + (brk.duration / 60);
                });

                if (end > currentTime) {
                    blocks.push({
                        type: 'work',
                        duration: (end - currentTime) * 60,
                        startHour: currentTime
                    });
                }

                const totalWorkMinutes = blocks
                    .filter(b => b.type === 'work')
                    .reduce((sum, b) => sum + b.duration, 0);

                const restDuration = Math.max(240, totalWorkMinutes / 2);

                blocks.push({
                    type: 'rest',
                    duration: restDuration,
                    startHour: end
                });

                return blocks;
            }

            formatForDisplay(schedule) {
                return schedule.map(day => {
                    const start = this.formatTime(day.start);
                    const end = this.formatTime(day.end);
                    const breaks = day.breaks.map(b =>
                        `${b.duration}min${b.time ? ` at ${this.formatTime(b.time)}` : ''}`
                    ).join(', ');

                    const flags = [];
                    if (day.nightShift) flags.push('Night Shift');
                    if (day.flexible) flags.push('Flexible');
                    if (day.offButActive) flags.push('Off but Active');

                    return `
                    <div class="schedule-day">
                        <strong>${day.day}</strong>: <span class="time">${start} - ${end}</span>
                        ${breaks ? `<div class="breaks">Breaks: ${breaks}</div>` : ''}
                        ${flags.length > 0 ? `<div class="flags">${flags.join(', ')}</div>` : ''}
                    </div>
                `;
                }).join('');
            }

            formatTime(time) {
                const hours = Math.floor(time);
                const minutes = Math.round((time - hours) * 60);
                return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
            }
        }

        // ========================================================================
        // PHASE 2: FINANCIAL CALCULATOR MODULE
        // ========================================================================

        class FinancialCalculator {
            constructor() {
                this.hourlyWage = 15;
                this.workersPerShift = 8;
                this.errorCost = 35;
                this.annualDays = 250;

                this.totalLoss = 0;
                this.zombieCost = 0;
                this.temporalDebt = 0;
                this.productivityLoss = 0;
                this.errorEvents = 0;
                this.emergencyShutdowns = 0;
                this.zombieHours = 0;

                this.startTime = Date.now();
            }

            updateConfigFromInputs() {
                this.hourlyWage = parseFloat(document.getElementById('hourlyWage').value);
                this.workersPerShift = parseInt(document.getElementById('workersPerShift').value);
                this.errorCost = parseFloat(document.getElementById('errorCost').value);
                this.annualDays = parseInt(document.getElementById('annualDays').value);
            }

            calculateProductivityLoss(workers) {
                let totalCapacity = 0;

                workers.forEach(({ worker }) => {
                    const state = worker.getState();
                    totalCapacity += state.capacity;
                });

                const averageEfficiency = totalCapacity / workers.length;
                const productivityLoss = (1 - averageEfficiency) * this.hourlyWage * workers.length;

                return productivityLoss;
            }

            calculateZombieCost(workers, deltaTime) {
                let zombieWorkers = 0;
                workers.forEach(({ worker }) => {
                    if (worker.gamma >= 0.7) {
                        zombieWorkers++;
                        // BUG FIX: Scale by actual deltaTime, not fixed 1/3600
                        this.zombieHours += (deltaTime / 3600);
                    }
                });

                return zombieWorkers * this.hourlyWage;
            }

            calculateTemporalDebt(workers) {
                // BUG FIX: Track new shutdowns only, not continuous state
                // Compare current shutdownCount to last recorded value
                let emergencyShutdownsThisCycle = 0;

                workers.forEach(({ worker }) => {
                    // Initialize tracking if not present
                    if (worker.lastShutdownCount === undefined) {
                        worker.lastShutdownCount = 0;
                    }

                    // Detect NEW shutdowns (count increased)
                    if (worker.shutdownCount > worker.lastShutdownCount) {
                        const newShutdowns = worker.shutdownCount - worker.lastShutdownCount;
                        emergencyShutdownsThisCycle += newShutdowns;
                        this.emergencyShutdowns += newShutdowns;
                        worker.lastShutdownCount = worker.shutdownCount;
                    }
                });

                const costPerSecond = this.hourlyWage / 3600;
                // 3 seconds penalty per shutdown (can be made configurable later)
                return emergencyShutdownsThisCycle * 3 * costPerSecond;
            }

            calculateErrorCost(workers, deltaTime) {
                let errorProbability = 0;
                workers.forEach(({ worker }) => {
                    errorProbability += Math.pow(worker.gamma, 2) * 0.1;
                });

                // BUG FIX: Scale probability by deltaTime to get correct rate
                // errorProbability is per-hour rate, so multiply by (deltaTime / 3600)
                const adjustedProbability = errorProbability * (deltaTime / 3600);

                if (Math.random() < adjustedProbability) {
                    this.errorEvents++;
                    return this.errorCost;
                }
                return 0;
            }

            update(workers, deltaTime) {
                this.updateConfigFromInputs();

                const hourlyFraction = deltaTime / 3600;

                const productivityLoss = this.calculateProductivityLoss(workers) * hourlyFraction;
                const zombieCost = this.calculateZombieCost(workers, deltaTime) * hourlyFraction;
                const temporalDebt = this.calculateTemporalDebt(workers);
                const errorCost = this.calculateErrorCost(workers, deltaTime);

                this.productivityLoss += productivityLoss;
                this.zombieCost += zombieCost;
                this.temporalDebt += temporalDebt;
                this.totalLoss = this.productivityLoss + this.zombieCost + this.temporalDebt + (this.errorEvents * this.errorCost);

                this.updateDisplay(workers);
            }

            updateDisplay(workers) {
                document.getElementById('totalLoss').textContent = `$${this.totalLoss.toFixed(2)}`;
                document.getElementById('zombieCost').textContent = `$${this.zombieCost.toFixed(2)}`;
                document.getElementById('temporalDebt').textContent = `$${this.temporalDebt.toFixed(2)}`;

                const avgGamma = workers.reduce((sum, { worker }) => sum + worker.gamma, 0) / workers.length;
                const criticalWorkers = workers.filter(({ worker }) => worker.gamma >= 0.7).length;
                const avgCapacity = workers.reduce((sum, { worker }) => sum + worker.getState().capacity, 0) / workers.length;

                document.getElementById('avgGamma').textContent = avgGamma.toFixed(3);
                document.getElementById('criticalWorkers').textContent = criticalWorkers;
                document.getElementById('avgCapacity').textContent = `${(avgCapacity * 100).toFixed(1)}%`;
                document.getElementById('zombieHours').textContent = this.zombieHours.toFixed(2);
                document.getElementById('errorEvents').textContent = this.errorEvents;

                const emergencyCount = workers.filter(({ worker }) => worker.shutdownCount > 0)
                    .reduce((sum, { worker }) => sum + worker.shutdownCount, 0);
                document.getElementById('emergencyCount').textContent = emergencyCount;

                const simTimeHours = (Date.now() - this.startTime) / 3600000;
                const hourlyLossRate = simTimeHours > 0 ? this.totalLoss / simTimeHours : 0;
                document.getElementById('lossRate').textContent = `$${hourlyLossRate.toFixed(2)}/hr`;

                document.getElementById('shiftProductivity').textContent = `$${this.productivityLoss.toFixed(2)}`;
                document.getElementById('shiftErrors').textContent = `$${(this.errorEvents * this.errorCost).toFixed(2)}`;
                document.getElementById('shiftDebt').textContent = `$${this.temporalDebt.toFixed(2)}`;

                const dailyLoss = simTimeHours > 0 ? this.totalLoss * (8 / simTimeHours) : 0;
                const annualLoss = dailyLoss * this.annualDays;

                document.getElementById('annualLoss').textContent = `$${annualLoss.toFixed(0)}`;

                const optimizedSavings = annualLoss * 0.267;
                document.getElementById('optimizedSavings').textContent = `$${optimizedSavings.toFixed(0)}`;

                const roi = optimizedSavings > 0 ? (optimizedSavings / 87500 * 100) : 0;
                document.getElementById('roiPotential').textContent = `${roi.toFixed(0)}%`;

                document.getElementById('lossDetails').textContent =
                    `Œ≥-based capacity degradation: ${(avgGamma * 100).toFixed(1)}%`;
                document.getElementById('zombieDetails').textContent =
                    `${criticalWorkers} workers at Œ≥ ‚â• 0.7`;
                document.getElementById('debtDetails').textContent =
                    `${emergencyCount} emergency shutdowns`;
            }

            reset() {
                this.totalLoss = 0;
                this.zombieCost = 0;
                this.temporalDebt = 0;
                this.productivityLoss = 0;
                this.errorEvents = 0;
                this.emergencyShutdowns = 0;
                this.zombieHours = 0;
                this.startTime = Date.now();
            }

            exportReport() {
                const simTimeHours = (Date.now() - this.startTime) / 3600000;
                const dailyLoss = simTimeHours > 0 ? this.totalLoss * (8 / simTimeHours) : 0;
                const annualLoss = dailyLoss * this.annualDays;

                const report = {
                    timestamp: new Date().toISOString(),
                    configuration: {
                        hourlyWage: this.hourlyWage,
                        workersPerShift: this.workersPerShift,
                        errorCost: this.errorCost,
                        annualDays: this.annualDays
                    },
                    currentShift: {
                        totalLoss: this.totalLoss,
                        productivityLoss: this.productivityLoss,
                        zombieCost: this.zombieCost,
                        temporalDebt: this.temporalDebt,
                        errorCosts: this.errorEvents * this.errorCost,
                        emergencyShutdowns: this.emergencyShutdowns,
                        zombieHours: this.zombieHours
                    },
                    projections: {
                        annualLoss: annualLoss,
                        optimizedSavings: annualLoss * 0.267,
                        implementationCost: 87500,
                        roi: (annualLoss * 0.267 / 87500 * 100)
                    }
                };

                const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `EARA_Financial_Report_${new Date().toISOString().split('T')[0]}.json`;
                a.click();
                URL.revokeObjectURL(url);
            }
        }

        // ========================================================================
        // PHASE 1: DARWISH WORKER CLASS (Circadian + Risk Translation)
        // ========================================================================

        class DarwishWorker {
            constructor(id, resilienceLevel = 'medium') {
                this.id = id;
                this.gamma = 0;
                this.permanentFatigue = 0;
                this.hasBurnedOut = false;
                this.maxCapacity = 1.0;
                this.shutdownCount = 0;

                // Multi-day tracking
                this.dayStartGamma = 0;
                this.dailyShutdowns = [];
                this.dailyMaxGamma = [];

                this.resilienceLevel = resilienceLevel;
                // Recovery rates scaled to match corrected fatigue rates
                // Base fatigue rate = 0.00233/min
                // Recovery = 2√ó faster = 0.00466/min
                // High resilience = 2√ó base recovery = 0.00932/min
                // Medium = 1.5√ó base = 0.00700/min  
                // Low = 1√ó base = 0.00466/min
                this.resilience = {
                    high: { recovery: 0.00932, threshold: 0.75 },
                    medium: { recovery: 0.00700, threshold: 0.70 },
                    low: { recovery: 0.00466, threshold: 0.65 }
                }[resilienceLevel];
            }

            tick(isWorking, deltaSeconds, currentHour) {
                const deltaMinutes = deltaSeconds / 60;

                const circadian = this.getCircadianAlertness(currentHour);

                // CRITICAL FIX: Correct time scaling
                // Target: Œ≥ = 0.7 at 5 hours (300 minutes) with circadian = 1.0
                // Rate = 0.7 / 300 = 0.00233 per minute
                // Previous value (0.15) was 64√ó too fast!
                const baseFatigueRate = 0.00233; // Per minute at peak circadian alertness

                const fatigueRate = isWorking ?
                    (baseFatigueRate * (1 / circadian)) * deltaMinutes :
                    -this.resilience.recovery * deltaMinutes;

                this.gamma = Math.max(0, Math.min(1, this.gamma + fatigueRate));

                if (this.gamma >= 1.0 && !this.hasBurnedOut) {
                    this.permanentFatigue = Math.min(0.4, this.permanentFatigue + 0.05);
                    this.maxCapacity = Math.max(0.3, this.maxCapacity - 0.05);
                    this.hasBurnedOut = true;
                    this.shutdownCount++;
                }

                if (this.gamma < 0.3 && this.hasBurnedOut) {
                    this.hasBurnedOut = false;
                }

                return this.getState(currentHour);
            }

            getCircadianAlertness(hour) {
                // Biologically grounded sine wave model
                // Based on circadian rhythm research (peak ~10am, trough ~10pm)
                // œÜ (phase) = 4 hours (to align peak at 10:00)
                // sin reaches maximum at œÄ/2, so: t - œÜ = 6 ‚Üí t = 10
                // Amplitude scaled to range [0.3, 1.0]

                const phi = 4; // Phase shift: peak at 10:00 (4 + 6 quarter-cycle = 10)
                const period = 24; // 24-hour cycle

                // sin(2œÄ(t - œÜ)/24) ranges from -1 to +1
                const sineValue = Math.sin(2 * Math.PI * (hour - phi) / period);

                // Scale from [-1, 1] to [0.3, 1.0]
                // 0.3 = minimum alertness (22:00/10pm trough)
                // 1.0 = maximum alertness (10:00/10am peak)
                const minAlertness = 0.3;
                const maxAlertness = 1.0;
                const alertnessRange = maxAlertness - minAlertness;

                const alertness = minAlertness + (alertnessRange * (sineValue + 1) / 2);

                return Math.max(minAlertness, Math.min(maxAlertness, alertness));
            }

            getState(currentHour = 8) {
                const effectiveGamma = Math.min(1, this.gamma + this.permanentFatigue);
                const capacity = Math.max(0, this.maxCapacity * (1 - effectiveGamma));

                let state;
                if (effectiveGamma >= 1.0) {
                    state = 'shutdown';
                } else if (effectiveGamma >= 0.7) {
                    state = 'critical';
                } else if (effectiveGamma >= 0.3) {
                    state = 'degraded';
                } else {
                    state = 'optimal';
                }

                const circadian = this.getCircadianAlertness(currentHour);
                const accidentRisk = Math.min(1, effectiveGamma * (1 / circadian));
                const errorProb = Math.min(1, effectiveGamma * 0.8);

                return {
                    id: this.id,
                    fatigue: this.gamma,
                    permanentFatigue: this.permanentFatigue,
                    capacity: capacity,
                    state: state,
                    performanceMultiplier: capacity,
                    hasBurnedOut: this.hasBurnedOut,
                    maxCapacity: this.maxCapacity,
                    resilienceLevel: this.resilienceLevel,
                    circadianAlertness: circadian,
                    accidentRisk: accidentRisk,
                    errorProb: errorProb,
                    shutdownCount: this.shutdownCount
                };
            }

            startNewDay() {
                this.dayStartGamma = this.gamma;
                this.dailyShutdowns.push(this.shutdownCount);
                this.dailyMaxGamma.push(0);
            }

            hardReset() {
                this.gamma = 0;
                this.permanentFatigue = 0;
                this.hasBurnedOut = false;
                this.maxCapacity = 1.0;
                this.shutdownCount = 0;
                this.dayStartGamma = 0;
                this.dailyShutdowns = [];
                this.dailyMaxGamma = [];
            }
        }

        // ========================================================================
        // SIMULATION ENGINE
        // ========================================================================

        class EARASimulation {
            constructor() {
                const { Engine, Render, Runner, World, Bodies, Body } = Matter;

                this.engine = Engine.create({
                    gravity: { x: 0, y: 0 }
                });

                const canvas = document.getElementById('eara-canvas');
                this.render = Render.create({
                    canvas: canvas,
                    engine: this.engine,
                    options: {
                        width: CONFIG.canvas.width,
                        height: CONFIG.canvas.height,
                        wireframes: false,
                        background: '#0a0a0a'
                    }
                });

                Render.run(this.render);
                this.runner = Runner.create();

                const walls = [
                    Bodies.rectangle(CONFIG.canvas.width / 2, 0, CONFIG.canvas.width, 50, {
                        isStatic: true,
                        render: { fillStyle: '#2a2a2a' }
                    }),
                    Bodies.rectangle(CONFIG.canvas.width / 2, CONFIG.canvas.height, CONFIG.canvas.width, 50, {
                        isStatic: true,
                        render: { fillStyle: '#2a2a2a' }
                    }),
                    Bodies.rectangle(0, CONFIG.canvas.height / 2, 50, CONFIG.canvas.height, {
                        isStatic: true,
                        render: { fillStyle: '#2a2a2a' }
                    }),
                    Bodies.rectangle(CONFIG.canvas.width, CONFIG.canvas.height / 2, 50, CONFIG.canvas.height, {
                        isStatic: true,
                        render: { fillStyle: '#2a2a2a' }
                    })
                ];
                World.add(this.engine.world, walls);

                this.workers = [];
                this.isRunning = false;
                this.isPaused = false;
                this.realWorldTime = 0;  // Real-world elapsed seconds (wall clock)
                this.worldTime = 0;       // Simulation time in seconds
                this.timeMultiplier = 60; // Speed multiplier (60√ó default for fast testing)
                this.currentDay = 1;
                this.maxDays = 7;
                this.dayStartTime = 0;
                this.currentSchedule = 'sprint';
                this.schedulePhase = 0;
                this.phaseTime = 0;
                this.startHour = 8;

                // PHASE 1: Schedule parser initialization
                this.parser = new ScheduleParser({
                    llmEndpoint: 'http://localhost:52625/v1',
                    minConfidence: 0.7
                });
                this.customSchedule = null;
                this.customScheduleData = null;

                // PHASE 2: Financial calculator initialization
                this.financialCalculator = new FinancialCalculator();

                // TEMPORAL DEBT TRACKING
                this.temporalDebt = 0;  // Total accumulated debt in seconds
                this.emergencyShutdowns = 0;
                this.scheduledRests = 0;
                this.EMERGENCY_COST = 5;  // Emergency shutdown takes 5 seconds
                this.SCHEDULED_COST = 2;   // Scheduled rest takes 2 seconds
                this.DEBT_PER_SHUTDOWN = 3; // Difference: 5 - 2 = 3 seconds debt

                this.createWorkers();
                this.setupControls();
                this.updateMetrics(this.startHour);
            }

            createWorkers() {
                const { Bodies, World, Body } = Matter;

                const resilienceLevels = ['high', 'high', 'medium', 'medium', 'medium', 'medium', 'low', 'low'];

                // Calculate safe positions inside canvas (1000√ó600)
                // With 30px radius, safe zone is 30-970 (X) and 30-570 (Y)
                const cols = 4;
                const rows = 2;
                const xSpacing = (CONFIG.canvas.width - 100) / cols;  // Leave 50px padding each side
                const ySpacing = (CONFIG.canvas.height - 100) / rows;  // Leave 50px padding top/bottom

                for (let i = 0; i < 8; i++) {
                    const col = i % cols;
                    const row = Math.floor(i / cols);

                    const x = 80 + col * xSpacing + xSpacing / 2;  // Center in each cell
                    const y = 80 + row * ySpacing + ySpacing / 2;

                    const body = Bodies.circle(x, y, 30, {
                        restitution: 0.9,
                        friction: 0.001,
                        render: {
                            fillStyle: CONFIG.colors.optimal
                        }
                    });

                    Body.setVelocity(body, {
                        x: (Math.random() - 0.5) * 5,
                        y: (Math.random() - 0.5) * 5
                    });

                    const worker = new DarwishWorker(`W${i + 1}`, resilienceLevels[i]);

                    this.workers.push({ body, worker });
                    World.add(this.engine.world, body);
                }
            }

            setupControls() {
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('pauseBtn').addEventListener('click', () => this.pause());
                document.getElementById('resetBtn').addEventListener('click', () => this.reset());
                document.getElementById('scheduleSelect').addEventListener('change', (e) => {
                    this.currentSchedule = e.target.value;
                    this.reset();
                });

                const startTimeSlider = document.getElementById('startTimeSlider');
                const startTimeValue = document.getElementById('startTimeValue');

                startTimeSlider.addEventListener('input', (e) => {
                    const hour = parseInt(e.target.value);
                    startTimeValue.textContent = hour.toString().padStart(2, '0') + ':00';
                    this.startHour = hour;

                    if (this.isRunning) {
                        this.reset();
                    }
                });

                // Speed multiplier control
                const speedSelect = document.getElementById('speedSelect');
                const speedValue = document.getElementById('speedValue');

                speedSelect.addEventListener('change', (e) => {
                    this.timeMultiplier = parseInt(e.target.value);
                    speedValue.textContent = `${this.timeMultiplier}√ó`;
                });

                // PHASE 1: Parser button handlers
                document.getElementById('parseBtn').addEventListener('click',
                    () => this.parseSchedule());

                document.getElementById('clearScheduleBtn').addEventListener('click', () => {
                    document.getElementById('scheduleInput').value = '';
                    document.getElementById('parsedScheduleDisplay').style.display = 'none';
                    document.getElementById('parseStatus').style.display = 'none';
                });

                document.getElementById('runCustomSim').addEventListener('click',
                    () => this.runWithCustomSchedule());

                // Example schedule buttons
                document.getElementById('example1').addEventListener('click', () => {
                    document.getElementById('scheduleInput').value =
                        `Mon: 9am-5pm (1hr lunch at noon)
Tue: 9am-5pm (1hr lunch at noon)
Wed: 9am-5pm (1hr lunch at noon)
Thu: 9am-5pm (1hr lunch at noon)
Fri: 9am-5pm (1hr lunch at noon)`;
                });

                document.getElementById('example2').addEventListener('click', () => {
                    document.getElementById('scheduleInput').value =
                        `Mon: 4am-12:30pm (30 min break)
Tue: 4am-12:30pm (30 min break)
Wed: 4am-12:30pm (30 min break)
Thu: 4am-12:30pm (30 min break)
Fri: 4am-12:30pm (30 min break)`;
                });

                document.getElementById('example3').addEventListener('click', () => {
                    document.getElementById('scheduleInput').value =
                        `Mon: 10pm-6am (30 min break at 2am)
Tue: 10pm-6am (30 min break at 2am)
Wed: 10pm-6am (30 min break at 2am)
Thu: 10pm-6am (30 min break at 2am)
Fri: Off`;
                });

                // PHASE 2: Export financial report
                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.financialCalculator.exportReport();
                });
            }

            async parseSchedule() {
                const text = document.getElementById('scheduleInput').value;
                const statusDiv = document.getElementById('parseStatus');

                if (!text.trim()) {
                    statusDiv.className = 'parse-status error';
                    statusDiv.style.display = 'block';
                    statusDiv.textContent = '‚ö†Ô∏è Please enter a schedule';
                    return;
                }

                statusDiv.className = 'parse-status';
                statusDiv.style.display = 'block';
                statusDiv.textContent = '‚è≥ Parsing...';

                try {
                    const result = await this.parser.parse(text);

                    if (result.error) {
                        statusDiv.className = 'parse-status error';
                        statusDiv.textContent = `‚ùå Parse failed: ${result.error}`;
                        return;
                    }

                    if (result.schedule.length === 0) {
                        statusDiv.className = 'parse-status warning';
                        statusDiv.textContent = '‚ö†Ô∏è No schedule detected. Try adding more detail.';
                        return;
                    }

                    statusDiv.className = 'parse-status success';
                    statusDiv.textContent = `‚úÖ Parsed ${result.schedule.length} day(s) - ${Math.round(result.confidence * 100)}% confidence (${result.source})`;

                    this.displayParsedSchedule(result);

                    // Convert to worker configs with validation
                    const configResult = this.parser.toWorkerConfigs(result);
                    this.customSchedule = configResult.configs;

                    // Display warnings if any edge cases detected
                    if (configResult.warnings && configResult.warnings.length > 0) {
                        statusDiv.className = 'parse-status warning';
                        statusDiv.innerHTML = `‚úÖ Parsed ${result.schedule.length} day(s)<br><br><strong>Warnings:</strong><br>` +
                            configResult.warnings.map(w => `‚Ä¢ ${w}`).join('<br>');
                    }

                } catch (error) {
                    statusDiv.className = 'parse-status error';
                    statusDiv.textContent = `‚ùå Error: ${error.message}`;
                }
            }

            displayParsedSchedule(parseResult) {
                const container = document.getElementById('parsedScheduleDisplay');
                const breakdown = document.getElementById('scheduleBreakdown');

                breakdown.innerHTML = this.parser.formatForDisplay(parseResult.schedule);
                container.style.display = 'block';
            }

            runWithCustomSchedule() {
                if (!this.customSchedule || this.customSchedule.length === 0) {
                    alert('No custom schedule loaded. Please parse a schedule first.');
                    return;
                }

                this.reset();

                const dayConfig = this.customSchedule[0];
                this.currentSchedule = 'custom';
                this.customScheduleData = dayConfig.schedule;
                this.startHour = dayConfig.startHour || 8;

                document.getElementById('startTimeSlider').value = this.startHour;
                document.getElementById('startTimeValue').textContent =
                    this.startHour.toString().padStart(2, '0') + ':00';

                this.start();
            }

            start() {
                if (!this.isRunning) {
                    this.isRunning = true;
                    this.isPaused = false;
                    Matter.Runner.run(this.runner, this.engine);
                    this.animate();
                } else if (this.isPaused) {
                    this.isPaused = false;
                }
            }

            pause() {
                this.isPaused = !this.isPaused;
            }

            reset() {
                this.isRunning = false;
                this.isPaused = false;
                this.realWorldTime = 0;
                this.worldTime = 0;
                this.currentDay = 1;
                this.dayStartTime = 0;
                this.schedulePhase = 0;
                this.phaseTime = 0;

                Matter.Runner.stop(this.runner);

                this.workers.forEach(({ body, worker }) => {
                    worker.hardReset();
                    Matter.Body.setPosition(body, {
                        x: body.position.x,
                        y: body.position.y
                    });
                    Matter.Body.setVelocity(body, {
                        x: (Math.random() - 0.5) * 5,
                        y: (Math.random() - 0.5) * 5
                    });
                    body.render.fillStyle = CONFIG.colors.optimal;
                });

                // PHASE 2: Reset financial calculator
                this.financialCalculator.reset();

                // Reset temporal debt tracking
                this.temporalDebt = 0;
                this.emergencyShutdowns = 0;
                this.scheduledRests = 0;

                this.updateMetrics(this.startHour);
            }

            advanceDay() {
                this.currentDay++;
                this.dayStartTime = this.worldTime;

                console.log(`üìÖ Day ${this.currentDay}/${this.maxDays} starting...`);

                this.schedulePhase = 0;
                this.phaseTime = 0;

                this.workers.forEach(({ worker }) => {
                    worker.startNewDay();
                });
            }

            endSimulation() {
                console.log(`üèÅ Simulation complete - ${this.maxDays} days finished`);
                this.pause();

                alert(`Simulation Complete!\n\nRan for ${this.maxDays} days.\n\nCheck the metrics below for final results.`);
            }

            animate() {
                if (!this.isRunning) return;

                if (!this.isPaused) {
                    this.update();
                }

                requestAnimationFrame(() => this.animate());
            }

            update() {
                const deltaTime = 1 / 60;  // 60 FPS = 1/60 second per frame (wall-clock time)
                const simulatedDelta = deltaTime * this.timeMultiplier;  // Apply speed multiplier

                this.realWorldTime += deltaTime;           // Real wall-clock time
                this.worldTime += simulatedDelta;          // Simulated time (accelerated)
                this.phaseTime += simulatedDelta / 60;     // Phase time in minutes

                // Check if 24 hours have passed (86400 seconds)
                if (this.worldTime - this.dayStartTime >= 86400) {
                    this.advanceDay();
                    if (this.currentDay > this.maxDays) {
                        this.endSimulation();
                        return;
                    }
                }

                const currentWorldHour = (this.startHour + (this.worldTime / 3600)) % 24;

                const schedule = this.customScheduleData || CONFIG.schedules[this.currentSchedule];
                const currentPhase = schedule[this.schedulePhase];

                if (this.phaseTime >= currentPhase.duration) {
                    const nextPhaseIndex = (this.schedulePhase + 1) % schedule.length;
                    const nextPhase = schedule[nextPhaseIndex];

                    // Track scheduled rest transitions
                    if (nextPhase.type === 'rest') {
                        this.scheduledRests++;
                    }

                    this.schedulePhase = nextPhaseIndex;
                    this.phaseTime = 0;
                }

                const isWorking = schedule[this.schedulePhase].type === 'work';

                this.workers.forEach(({ body, worker }) => {
                    const prevShutdowns = worker.shutdownCount;
                    const state = worker.tick(isWorking, simulatedDelta, currentWorldHour);

                    // Check if a new shutdown occurred
                    if (worker.shutdownCount > prevShutdowns) {
                        this.emergencyShutdowns++;
                        this.temporalDebt += this.DEBT_PER_SHUTDOWN;
                        console.log(`‚ö†Ô∏è Emergency shutdown! Worker ${state.id} - Debt now: ${this.temporalDebt.toFixed(1)}s`);
                    }

                    const currentVel = body.velocity;
                    const baseSpeed = Math.sqrt(currentVel.x * currentVel.x + currentVel.y * currentVel.y);

                    const minSpeed = 0.5;
                    const targetSpeed = Math.max(minSpeed, 2 * state.performanceMultiplier);

                    if (baseSpeed > 0.01) {
                        const scale = targetSpeed / baseSpeed;
                        Matter.Body.setVelocity(body, {
                            x: currentVel.x * scale,
                            y: currentVel.y * scale
                        });
                    } else {
                        Matter.Body.setVelocity(body, {
                            x: (Math.random() - 0.5) * minSpeed * 2,
                            y: (Math.random() - 0.5) * minSpeed * 2
                        });
                    }

                    const jitterMultiplier = state.hasBurnedOut ? 1.5 : 1.0;
                    const jitterAmount = state.fatigue * 2 * jitterMultiplier;
                    Matter.Body.applyForce(body, body.position, {
                        x: (Math.random() - 0.5) * jitterAmount * 0.0001,
                        y: (Math.random() - 0.5) * jitterAmount * 0.0001
                    });

                    body.render.fillStyle = CONFIG.colors[state.state];
                });

                // PHASE 2: Financial update
                this.financialCalculator.update(this.workers, simulatedDelta);

                this.updateMetrics(currentWorldHour);
            }

            updateMetrics(currentWorldHour = 8) {
                // Real-world time (wall clock)
                const realSeconds = Math.floor(this.realWorldTime);
                const realMins = Math.floor(realSeconds / 60);
                const realSecs = realSeconds % 60;
                const realTimeString = `${realMins.toString().padStart(2, '0')}:${realSecs.toString().padStart(2, '0')}`;

                // Simulation time
                const simSeconds = Math.floor(this.worldTime);
                const simHours = Math.floor(simSeconds / 3600);
                const simMins = Math.floor((simSeconds % 3600) / 60);
                const simSecs = simSeconds % 60;

                // Calculate day number
                const dayNumber = Math.floor(simSeconds / 86400) + 1;
                const hoursInDay = simHours % 24;

                // Calculate speed multiplier
                const speedMultiplier = this.realWorldTime > 0 ?
                    (this.worldTime / this.realWorldTime).toFixed(0) : 1;

                // Format simulation time
                const simTimeString = `${hoursInDay.toString().padStart(2, '0')}:${simMins.toString().padStart(2, '0')}:${simSecs.toString().padStart(2, '0')}`;

                // Show both times with clear distinction
                document.getElementById('elapsedTime').textContent =
                    `${simTimeString} (Day ${this.currentDay}/${this.maxDays}) | Real: ${realTimeString} | Speed: ${speedMultiplier}√ó`;

                // Calculate average gamma and gamma rate for debug panel
                let totalGamma = 0;
                let totalGammaRate = 0;
                let workingCount = 0;

                this.workers.forEach(({ worker }) => {
                    const state = worker.getState(currentWorldHour);
                    totalGamma += state.fatigue;

                    // Calculate dŒ≥/dt based on current state
                    const circadian = worker.getCircadianAlertness(currentWorldHour);
                    const fatigueRate = (0.00233 * (1 / circadian)); // Per minute while working (CORRECTED)
                    totalGammaRate += fatigueRate;
                    if (state.fatigue > 0.1) workingCount++;
                });

                const avgGamma = totalGamma / this.workers.length;
                const avgGammaRate = totalGammaRate / this.workers.length;

                // Update debug panel
                document.getElementById('avgGamma').textContent = avgGamma.toFixed(3);

                // Show rate per minute (positive = accumulating, negative = recovering)
                const schedule = this.customScheduleData || CONFIG.schedules[this.currentSchedule];
                const isWorking = schedule[this.schedulePhase].type === 'work';
                const displayRate = isWorking ? avgGammaRate : -(0.007); // Recovery rate (medium resilience)
                document.getElementById('gammaRate').textContent =
                    `${displayRate >= 0 ? '+' : ''}${displayRate.toFixed(3)}/min`;

                // Project Œ≥ at 4 hours assuming current rate
                const gamma4hr = Math.min(1.0, avgGamma + (avgGammaRate * 240)); // 240 minutes = 4 hours
                document.getElementById('gamma4hr').textContent = gamma4hr.toFixed(3);

                const metricsContainer = document.getElementById('workerMetrics');
                metricsContainer.innerHTML = '';

                this.workers.forEach(({ worker }) => {
                    const state = worker.getState(currentWorldHour);

                    const card = document.createElement('div');
                    card.className = `worker-metric ${state.state}`;

                    card.innerHTML = `
                    <h4>${state.id}</h4>
                    <div class="value">${Math.round(state.capacity * 100)}%</div>
                    <div class="label">${state.state.toUpperCase()}</div>
                    <div class="label" style="margin-top: 5px;">Œ≥: ${state.fatigue.toFixed(3)}</div>
                `;

                    metricsContainer.appendChild(card);
                });

                // Update Temporal Debt Dashboard
                this.updateTemporalDebtDisplay();
            }

            updateTemporalDebtDisplay() {
                // Update main debt value
                document.getElementById('debtValue').textContent = this.temporalDebt.toFixed(1);

                // Update breakdown stats
                document.getElementById('emergencyShutdowns').textContent = this.emergencyShutdowns;
                document.getElementById('scheduledRests').textContent = this.scheduledRests;
                document.getElementById('totalRecoveries').textContent =
                    this.emergencyShutdowns + this.scheduledRests;

                // Determine verdict and update styling
                const panel = document.getElementById('temporalDebtPanel');
                const verdict = document.getElementById('debtVerdict');

                let verdictClass, verdictText;

                if (this.temporalDebt < 5) {
                    verdictClass = 'pass';
                    verdictText = '‚úÖ PASS';
                } else if (this.temporalDebt < 10) {
                    verdictClass = 'acceptable';
                    verdictText = '‚ö†Ô∏è ACCEPTABLE';
                } else if (this.temporalDebt < 20) {
                    verdictClass = 'misaligned';
                    verdictText = 'üî∂ MISALIGNED';
                } else {
                    verdictClass = 'catastrophic';
                    verdictText = 'üî¥ CATASTROPHIC';
                }

                // Update panel border
                panel.className = `temporal-debt-panel ${verdictClass}`;

                // Update verdict badge
                verdict.className = `debt-verdict ${verdictClass}`;
                verdict.textContent = verdictText;
            }
        }

        // ========================================================================
        // INITIALIZE SIMULATION
        // ========================================================================

        let simulation;

        window.addEventListener('DOMContentLoaded', () => {
            simulation = new EARASimulation();
        });


        // === COMPARISON MODE ENGINE ===

        class ComparisonSimulation {
            constructor() {
                this.active = false;
                this.sprintSim = null;
                this.traditionalSim = null;
                this.syncedTime = 0;
                this.realStartTime = null;
                this.animationFrame = null;
                this.isPaused = false;
                this.speed = 60; // Default 60x speed for comparison
            }

            initialize() {
                const workers = parseInt(document.getElementById('workersPerShift')?.value || '10');
                const wage = parseFloat(document.getElementById('hourlyWage')?.value || '15');
                const errorCost = parseFloat(document.getElementById('errorCost')?.value || '500');

                this.sprintSim = {
                    workers: [],
                    scheduleType: '4hr Sprint',
                    duration: 4,
                    totalTime: 0,
                    financials: { productivityLoss: 0, errorCosts: 0, temporalDebt: 0 },
                    wage: wage,
                    errorCost: errorCost,
                    emergencyShutdowns: 0,
                    errorEvents: 0,
                    zombieHours: 0
                };

                this.traditionalSim = {
                    workers: [],
                    scheduleType: '8hr Traditional',
                    duration: 8,
                    totalTime: 0,
                    financials: { productivityLoss: 0, errorCosts: 0, temporalDebt: 0 },
                    wage: wage,
                    errorCost: errorCost,
                    emergencyShutdowns: 0,
                    errorEvents: 0,
                    zombieHours: 0
                };

                // Initialize workers for both simulations
                for (let i = 0; i < workers; i++) {
                    this.sprintSim.workers.push(this.createWorker(i, '4hr'));
                    this.traditionalSim.workers.push(this.createWorker(i, '8hr'));
                }

                this.syncedTime = 0;
                this.realStartTime = performance.now();
                this.active = true;
                this.isPaused = false;
            }

            createWorker(id, type) {
                return {
                    id: `${type}-W${id + 1}`,
                    gamma: 0,
                    capacity: 1.0,
                    state: 'optimal',
                    hoursWorked: 0,
                    temporalDebt: 0,
                    shutdowns: 0
                };
            }

            step(deltaMinutes) {
                if (this.isPaused || !this.active) return;

                this.updateSimulation(this.sprintSim, deltaMinutes);
                this.updateSimulation(this.traditionalSim, deltaMinutes);

                this.syncedTime += deltaMinutes;

                this.updateUI();
            }

            updateSimulation(sim, deltaMinutes) {
                const deltaHours = deltaMinutes / 60;
                sim.totalTime += deltaMinutes;
                const hoursElapsed = sim.totalTime / 60;

                sim.workers.forEach(worker => {
                    worker.hoursWorked += deltaHours;

                    // Calculate gamma based on schedule type
                    if (sim.duration === 4) {
                        // 4hr Sprint: Œ≥ = 0.15t (linear, stays in optimal)
                        worker.gamma = 0.15 * worker.hoursWorked;
                    } else {
                        // 8hr Traditional: Œ≥ = 0.06t¬≤ (quadratic, enters critical)
                        worker.gamma = 0.06 * Math.pow(worker.hoursWorked, 2);
                    }

                    // Capacity calculation
                    worker.capacity = Math.max(0, 1 - worker.gamma);

                    // State determination
                    if (worker.gamma >= 1.0) {
                        worker.state = 'shutdown';
                        worker.shutdowns++;
                        sim.emergencyShutdowns++;
                    } else if (worker.gamma >= 0.7) {
                        worker.state = 'critical';
                        sim.zombieHours += deltaHours;

                        // Error probability in critical state
                        const errorChance = (worker.gamma - 0.7) * 0.1 * deltaMinutes;
                        if (Math.random() < errorChance) {
                            sim.errorEvents++;
                            sim.financials.errorCosts += sim.errorCost;
                        }
                    } else if (worker.gamma >= 0.3) {
                        worker.state = 'degraded';
                    } else {
                        worker.state = 'optimal';
                    }

                    // Temporal debt accumulation
                    if (worker.gamma > 0.7) {
                        const debtRate = (worker.gamma - 0.7) * 60; // seconds per minute
                        worker.temporalDebt += debtRate * deltaMinutes;
                    }

                    // Productivity loss
                    const lossRate = Math.max(0, 1 - worker.capacity) * sim.wage;
                    sim.financials.productivityLoss += lossRate * deltaHours;
                });

                // Calculate temporal debt costs
                const totalDebt = sim.workers.reduce((sum, w) => sum + w.temporalDebt, 0);
                sim.financials.temporalDebt = (totalDebt / 3600) * sim.wage * 2; // Premium cost for recovery
            }

            updateUI() {
                this.updatePanel(this.sprintSim, 'sprint');
                this.updatePanel(this.traditionalSim, 'traditional');
                this.updateDeltaMetrics();
            }

            updatePanel(sim, type) {
                const prefix = type;
                const hours = Math.floor(sim.totalTime / 60);
                const minutes = Math.floor(sim.totalTime % 60);
                const seconds = Math.floor((sim.totalTime * 60) % 60);

                const timeEl = document.getElementById(`${prefix}Time`);
                if (timeEl) {
                    timeEl.textContent =
                        `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                }

                const avgGamma = sim.workers.reduce((sum, w) => sum + w.gamma, 0) / sim.workers.length;
                const avgCapacity = sim.workers.reduce((sum, w) => sum + w.capacity, 0) / sim.workers.length;
                const criticalCount = sim.workers.filter(w => w.state === 'critical' || w.state === 'shutdown').length;

                this.safeSetText(`${prefix}AvgGamma`, avgGamma.toFixed(3));
                this.safeSetText(`${prefix}AvgCapacity`, (avgCapacity * 100).toFixed(1) + '%');
                this.safeSetText(`${prefix}Critical`, criticalCount);
                this.safeSetText(`${prefix}Shutdowns`, sim.emergencyShutdowns);
                this.safeSetText(`${prefix}ZombieHours`, sim.zombieHours.toFixed(1));
                this.safeSetText(`${prefix}Errors`, sim.errorEvents);

                const totalLoss = sim.financials.productivityLoss + sim.financials.errorCosts + sim.financials.temporalDebt;
                this.safeSetText(`${prefix}TotalLoss`, '$' + totalLoss.toFixed(2));
                this.safeSetText(`${prefix}ProductivityLoss`, '$' + sim.financials.productivityLoss.toFixed(2));
                this.safeSetText(`${prefix}ErrorCosts`, '$' + sim.financials.errorCosts.toFixed(2));

                // Update worker mini cards
                this.updateWorkerMiniCards(sim, type);
            }

            safeSetText(id, text) {
                const el = document.getElementById(id);
                if (el) el.textContent = text;
            }

            updateWorkerMiniCards(sim, type) {
                const container = document.getElementById(`${type}Workers`);
                if (!container) return;

                container.innerHTML = '';

                sim.workers.forEach(worker => {
                    const card = document.createElement('div');
                    card.className = 'worker-mini-card';

                    let bgColor, textColor;
                    if (worker.gamma >= 1.0) {
                        bgColor = '#7f1d1d'; textColor = 'white';
                    } else if (worker.gamma >= 0.7) {
                        bgColor = '#dc2626'; textColor = 'white';
                    } else if (worker.gamma >= 0.3) {
                        bgColor = '#fbbf24'; textColor = 'black';
                    } else {
                        bgColor = '#10b981'; textColor = 'white';
                    }

                    card.style.background = bgColor;
                    card.style.color = textColor;
                    card.innerHTML = `W${worker.id.split('W')[1]}<br>Œ≥:${worker.gamma.toFixed(2)}`;
                    container.appendChild(card);
                });
            }

            updateDeltaMetrics() {
                const sprintAvgGamma = this.sprintSim.workers.reduce((s, w) => s + w.gamma, 0) / this.sprintSim.workers.length;
                const tradAvgGamma = this.traditionalSim.workers.reduce((s, w) => s + w.gamma, 0) / this.traditionalSim.workers.length;

                const gammaŒî = tradAvgGamma - sprintAvgGamma;
                const lossŒî = (this.traditionalSim.financials.productivityLoss + this.traditionalSim.financials.errorCosts + this.traditionalSim.financials.temporalDebt) -
                    (this.sprintSim.financials.productivityLoss + this.sprintSim.financials.errorCosts + this.sprintSim.financials.temporalDebt);
                const zombieŒî = this.traditionalSim.zombieHours - this.sprintSim.zombieHours;
                const shutdownŒî = this.traditionalSim.emergencyShutdowns - this.sprintSim.emergencyShutdowns;

                const deltaGammaEl = document.getElementById('deltaGamma');
                if (deltaGammaEl) {
                    deltaGammaEl.textContent = (gammaŒî >= 0 ? '+' : '') + gammaŒî.toFixed(3);
                    deltaGammaEl.className = 'delta-value ' + (gammaŒî > 0 ? 'negative-delta' : 'positive-delta');
                }

                const deltaLossEl = document.getElementById('deltaLoss');
                if (deltaLossEl) {
                    deltaLossEl.textContent = '$' + Math.abs(lossŒî).toFixed(2);
                    deltaLossEl.className = 'delta-value ' + (lossŒî > 0 ? 'negative-delta' : 'positive-delta');
                }

                const deltaZombieEl = document.getElementById('deltaZombie');
                if (deltaZombieEl) {
                    deltaZombieEl.textContent = (zombieŒî >= 0 ? '+' : '') + zombieŒî.toFixed(1) + ' hrs';
                    deltaZombieEl.className = 'delta-value ' + (zombieŒî > 0 ? 'negative-delta' : 'positive-delta');
                }

                const deltaShutdownsEl = document.getElementById('deltaShutdowns');
                if (deltaShutdownsEl) {
                    deltaShutdownsEl.textContent = (shutdownŒî >= 0 ? '+' : '') + shutdownŒî;
                    deltaShutdownsEl.className = 'delta-value ' + (shutdownŒî > 0 ? 'negative-delta' : 'positive-delta');
                }

                // Savings projection
                const annualDays = parseInt(document.getElementById('annualDays')?.value || '260');
                const annualSavings = lossŒî * annualDays;
                this.safeSetText('annualSavings', '$' + Math.abs(annualSavings).toFixed(0));
            }

            animate() {
                if (!this.active) return;

                const now = performance.now();
                const realDelta = (now - this.realStartTime) / 1000; // seconds
                this.realStartTime = now;

                const simDelta = realDelta * this.speed; // simulated seconds
                const simMinutes = simDelta / 60;

                this.step(simMinutes);

                // Auto-stop at 8 hours (traditional completes)
                if (this.syncedTime >= 8 * 60) {
                    this.pause();
                    return;
                }

                this.animationFrame = requestAnimationFrame(() => this.animate());
            }

            start() {
                if (!this.active) this.initialize();
                this.isPaused = false;
                this.realStartTime = performance.now();
                this.animate();
            }

            pause() {
                this.isPaused = true;
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                    this.animationFrame = null;
                }
            }

            reset() {
                this.pause();
                this.active = false;
                this.initialize();
                this.updateUI();
            }
        }

        // Initialize comparison mode
        let comparisonSim = new ComparisonSimulation();

        // Setup comparison mode toggle
        function initComparisonMode() {
            const toggleBtn = document.getElementById('toggleComparisonMode');
            const body = document.body;

            if (toggleBtn) {
                toggleBtn.addEventListener('click', () => {
                    if (body.classList.contains('comparison-mode')) {
                        body.classList.remove('comparison-mode');
                        toggleBtn.textContent = 'üîÑ Enable Comparison Mode';
                        comparisonSim.pause();
                    } else {
                        body.classList.add('comparison-mode');
                        toggleBtn.textContent = 'üîÑ Disable Comparison Mode';
                        // Auto-initialize when entering comparison mode
                        comparisonSim.initialize();
                        comparisonSim.updateUI();
                    }
                });
            }

            // Comparison controls
            const startBtn = document.getElementById('comparisonStart');
            const pauseBtn = document.getElementById('comparisonPause');
            const resetBtn = document.getElementById('comparisonReset');

            if (startBtn) startBtn.addEventListener('click', () => comparisonSim.start());
            if (pauseBtn) pauseBtn.addEventListener('click', () => comparisonSim.pause());
            if (resetBtn) resetBtn.addEventListener('click', () => comparisonSim.reset());
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initComparisonMode);
        } else {
            initComparisonMode();
        }

    </script>
</body>

</html>